const functions = require("firebase-functions");
const admin = require("firebase-admin");
const axios = require("axios");
const vision = require("@google-cloud/vision");

// ‚úÖ NUEVAS LIBRER√çAS INTEGRADAS
const cors = require("cors")({ origin: true });
const {
  generateRegistrationOptions,
  verifyRegistrationResponse,
  generateAuthenticationOptions,
  verifyAuthenticationResponse,
} = require("@simplewebauthn/server");

admin.initializeApp();
const visionClient = new vision.ImageAnnotatorClient();

// ‚úÖ NUEVA CONFIGURACI√ìN PARA WEBAUTHN
// Configuraci√≥n de WebAuthn (Relying Party)
const rpName = "Genius Keeper";
// IMPORTANTE: Este ID debe ser el dominio donde tu app est√° alojada, SIN el https://
const rpID = "geniuskeeper-36553.firebaseapp.com"; 
const origin = `https://${rpID}`;


// ===================================================================
// FUNCI√ìN HELPER PARA NOTIFICACIONES (C√ìDIGO EXISTENTE - SIN CAMBIOS)
// ===================================================================
const sendNotificationToUser = async (userId, notificationPayload, dataPayload) => {
    if (!userId) {
        functions.logger.log("sendNotificationToUser: No se proporcion√≥ userId.");
        return;
    }
    const tokensRef = admin.firestore().collection("users_metadata").doc(userId).collection("tokens");
    const tokensSnap = await tokensRef.get();
    if (tokensSnap.empty) {
        functions.logger.log(`No se encontraron tokens para el usuario ${userId}.`);
        await admin.firestore().collection("notifications").add({
            userId: userId,
            title: notificationPayload.title,
            body: notificationPayload.body,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            read: false,
            link: dataPayload.link || ''
        });
        return;
    }
    const tokens = tokensSnap.docs.map(doc => doc.id);
    const payload = { notification: notificationPayload, data: dataPayload };
    const response = await admin.messaging().sendEachForMulticast({ tokens, ...payload });
    functions.logger.log(`Notificaci√≥n enviada a ${response.successCount} de ${tokens.length} dispositivos para el usuario ${userId}.`);
    const tokensToRemove = [];
    response.responses.forEach((result, index) => {
        const error = result.error;
        if (error) {
            functions.logger.error(`Fallo al enviar al token ${tokens[index]}`, error);
            if (["messaging/invalid-registration-token", "messaging/registration-token-not-registered"].includes(error.code)) {
                tokensToRemove.push(tokensRef.doc(tokens[index]).delete());
            }
        }
    });
    await Promise.all(tokensToRemove);
    if (tokensToRemove.length > 0) {
        functions.logger.log(`Se limpiaron ${tokensToRemove.length} tokens inv√°lidos.`);
    }
    await admin.firestore().collection("notifications").add({
        userId: userId,
        title: notificationPayload.title,
        body: notificationPayload.body,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        read: false,
        link: dataPayload.link || ''
    });
    functions.logger.log(`Notificaci√≥n para ${userId} guardada en Firestore.`);
};


// ===================================================================
// FUNCIONES DE TRIGGERS EXISTENTES (C√ìDIGO EXISTENTE - SIN CAMBIOS)
// ===================================================================

exports.onReportCreated = functions.firestore
    .document("visit_reports/{reportId}")
    .onCreate(async (snap, context) => {
        const reportData = snap.data();
        const { reportId } = context.params;
        const masterUserEmail = "lacteoca@lacteoca.com";
        try {
            const masterUserRecord = await admin.auth().getUserByEmail(masterUserEmail);
            const masterUid = masterUserRecord.uid;
            await sendNotificationToUser(
                masterUid,
                {
                    title: "Nuevo Reporte de Visita üìä",
                    body: `${reportData.userName || "Un vendedor"} ha enviado un reporte desde ${reportData.posName || "un PDV"}.`
                },
                { link: `/reports/${reportId}` }
            );
        } catch (error) {
            functions.logger.error("Error en onReportCreated:", error);
        }
    });

exports.checkAndCreateReporter = functions.firestore
    .document("visit_reports/{reportId}")
    .onCreate(async (snap, context) => {
        const reportData = snap.data();
        const reporterName = reportData.userName;
        if (!reporterName) {
            functions.logger.log("El reporte no tiene nombre de usuario, no se hace nada.");
            return null;
        }
        const reportersRef = admin.firestore().collection("reporters");
        const q = reportersRef.where("name", "==", reporterName);
        try {
            const snapshot = await q.get();
            if (snapshot.empty) {
                functions.logger.log(`El repartidor "${reporterName}" no existe. Cre√°ndolo...`);
                await reportersRef.add({ name: reporterName, active: true });
                functions.logger.log(`Repartidor "${reporterName}" creado exitosamente.`);
            } else {
                functions.logger.log(`El repartidor "${reporterName}" ya existe.`);
            }
            return null;
        } catch (error) {
            functions.logger.error("Error al verificar o crear el repartidor:", error);
            return null;
        }
    });

exports.onTaskDelegated = functions.firestore
    .document("delegated_tasks/{taskId}")
    .onCreate(async (snap, context) => {
        const taskData = snap.data();
        const { taskId } = context.params;
        await sendNotificationToUser(
            taskData.delegatedToId,
            {
                title: "Nueva Tarea Asignada üìã",
                body: `Tienes una nueva tarea en ${taskData.posName}: ${taskData.details}`
            },
            { link: `/tasks/${taskId}` }
        );
    });

exports.scheduleVisitReminders = functions.pubsub
    .schedule("every day 09:00")
    .timeZone("America/Caracas")
    .onRun(async (context) => {
        functions.logger.log("Ejecutando revisi√≥n diaria de visitas vencidas...");
        const posRef = admin.firestore().collection("pos");
        const reportsRef = admin.firestore().collection("visit_reports");
        const allPosSnapshot = await posRef.where("active", "==", true).get();
        if (allPosSnapshot.empty) {
            functions.logger.log("No hay PDV activos para revisar.");
            return null;
        }
        const merchandiserId = "anonymous_merchandiser_uid";
        const now = new Date();
        for (const posDoc of allPosSnapshot.docs) {
            const posData = posDoc.data();
            const visitInterval = posData.visitInterval || 7;
            const lastReportSnapshot = await reportsRef
                .where("posId", "==", posDoc.id)
                .orderBy("createdAt", "desc")
                .limit(1)
                .get();
            let daysSinceLastVisit = Infinity;
            if (!lastReportSnapshot.empty) {
                const lastVisitDate = lastReportSnapshot.docs[0].data().createdAt.toDate();
                daysSinceLastVisit = (now - lastVisitDate) / (1000 * 60 * 60 * 24);
            }
            if (daysSinceLastVisit > visitInterval) {
                const overdueDays = Math.floor(daysSinceLastVisit - visitInterval);
                await sendNotificationToUser(
                    merchandiserId,
                    {
                        title: "Visita Vencida ‚è∞",
                        body: `La visita a ${posData.name} est√° vencida por ${overdueDays} d√≠a(s).`
                    },
                    { link: `/pos/${posDoc.id}` }
                );
            }
        }
        return null;
    });

exports.onReportDeleted = functions.firestore
    .document("visit_reports/{reportId}")
    .onDelete(async (snap, context) => {
        const { reportId } = context.params;
        const linkToDelete = `/reports/${reportId}`;
        functions.logger.log(`Reporte ${reportId} eliminado. Buscando notificaci√≥n con el enlace: ${linkToDelete}`);
        const notificationsRef = admin.firestore().collection("notifications");
        const q = notificationsRef.where("link", "==", linkToDelete);
        try {
            const snapshot = await q.get();
            if (snapshot.empty) {
                functions.logger.log("No se encontr√≥ ninguna notificaci√≥n asociada para eliminar.");
                return null;
            }
            const batch = admin.firestore().batch();
            snapshot.forEach(doc => {
                functions.logger.log(`Eliminando notificaci√≥n ${doc.id}`);
                batch.delete(doc.ref);
            });
            await batch.commit();
            functions.logger.log("Notificaci√≥n(es) asociada(s) eliminada(s) con √©xito.");
            return null;
        } catch (error) {
            functions.logger.error("Error al eliminar la notificaci√≥n asociada:", error);
            return null;
        }
    });

// ===================================================================
// --- FUNCI√ìN "GENIUS" PARA GEOCODIFICACI√ìN (C√ìDIGO EXISTENTE - SIN CAMBIOS) ---
// ===================================================================
exports.geocodeAddress = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "El usuario debe estar autenticado.");
  }
  const { address, location: userLocation } = data;
  if (!address) {
    throw new functions.https.HttpsError("invalid-argument", "Se debe proporcionar una direcci√≥n.");
  }
  
  const API_KEY_GEOCODING = functions.config().genius.maps_api_key;
  if (!API_KEY_GEOCODING) {
      throw new functions.https.HttpsError("internal", "La clave de API de Maps no est√° configurada.");
  }

  let url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&region=ve&key=${API_KEY_GEOCODING}`;

  if (userLocation && userLocation.lat && userLocation.lng) {
      const locationBias = `circle:50000@${userLocation.lat},${userLocation.lng}`;
      url += `&locationbias=${encodeURIComponent(locationBias)}`;
  }

  try {
    const response = await axios.get(url);
    const geocodeData = response.data;
    if (geocodeData.status === "OK" && geocodeData.results.length > 0) {
      const location = geocodeData.results[0].geometry.location;
      return { lat: location.lat, lng: location.lng };
    } else {
      throw new functions.https.HttpsError("not-found", `No se encontraron coordenadas para la direcci√≥n. Estado: ${geocodeData.status}`);
    }
  } catch (error) {
    functions.logger.error("Error en la llamada a la API de Geocoding:", error);
    throw new functions.https.HttpsError("internal", "Ocurri√≥ un error al contactar el servicio de geocodificaci√≥n.");
  }
});


// ===================================================================
// --- FUNCI√ìN "GENIUS VISION" (C√ìDIGO EXISTENTE - SIN CAMBIOS) ---
// ===================================================================
exports.processImageForDate = functions.runWith({ minInstances: 1 }).https.onCall(async (data, context) => {
    if (!context.auth) {
        throw new functions.https.HttpsError("unauthenticated", "El usuario debe estar autenticado.");
    }
    if (!data.imageBase64) {
        throw new functions.https.HttpsError("invalid-argument", "Se debe proporcionar una imagen en formato base64.");
    }

    const API_KEY_VISION = functions.config().genius.vision_api_key;
    if (!API_KEY_VISION) {
        throw new functions.https.HttpsError("internal", "La clave de API de Vision no est√° configurada.");
    }
    const url = `https://vision.googleapis.com/v1/images:annotate?key=${API_KEY_VISION}`;

    const requestBody = {
        requests: [{
            image: { content: data.imageBase64 },
            features: [{ type: "TEXT_DETECTION" }],
        }],
    };

    try {
        const response = await axios.post(url, requestBody);
        const visionData = response.data;
        const detection = visionData.responses[0]?.fullTextAnnotation;

        if (detection) {
            const fullText = detection.text;
            functions.logger.log("Texto detectado:", fullText);
            
            const dateRegex = /(\d{1,2}[\s\.\/-]\d{1,2}[\s\.\/-]\d{2,4})|(\d{4}[\s\.\/-]\d{1,2}[\s\.\/-]\d{1,2})/g;
            const matches = fullText.match(dateRegex);

            if (matches && matches.length > 0) {
                functions.logger.log("Fecha encontrada:", matches[0]);
                return { date: matches[0] };
            } else {
                throw new functions.https.HttpsError("not-found", "No se encontr√≥ un formato de fecha v√°lido en la imagen.");
            }
        } else {
            throw new functions.https.HttpsError("not-found", "No se detect√≥ texto en la imagen.");
        }
    } catch (error) {
        functions.logger.error("Error en la API de Vision:", error.response?.data || error.message);
        throw new functions.https.HttpsError("internal", "Ocurri√≥ un error al procesar la imagen.");
    }
});


// ===================================================================
// --- FUNCIONES "GENIUS AUTH" PARA ACCESO CON HUELLA (WEBAUTHN) ---
// ===================================================================

// Funci√≥n 1: Genera las opciones para registrar un nuevo dispositivo
exports.generateRegistrationOptions = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "El usuario debe estar autenticado.");
  }

  const { uid, token } = context.auth;
  const { email, displayName } = token;
  
  const userAuthenticatorsRef = admin.firestore().collection("users_metadata").doc(uid).collection("authenticators");
  const snapshot = await userAuthenticatorsRef.get();
  const existingAuthenticators = snapshot.docs.map(doc => {
      const data = doc.data();
      return {
          ...data,
          id: Buffer.from(data.credentialID, 'base64url'),
      };
  });

  const options = await generateRegistrationOptions({
    rpName,
    rpID,
    userID: uid,
    userName: email,
    userDisplayName: displayName || email,
    attestationType: "none",
    excludeCredentials: existingAuthenticators.map(auth => ({
        id: auth.id,
        type: 'public-key',
        transports: auth.transports,
    })),
    authenticatorSelection: {
      residentKey: "preferred",
      userVerification: "preferred",
      authenticatorAttachment: "platform",
    },
  });

  await admin.firestore().collection("users_metadata").doc(uid).set({ webAuthnChallenge: options.challenge }, { merge: true });

  return options;
});


// Funci√≥n 2: Verifica la respuesta del navegador y guarda el nuevo autenticador
exports.verifyRegistration = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "El usuario debe estar autenticado.");
  }
  const { uid } = context.auth;
  const { registrationResponse } = data;

  const userDoc = await admin.firestore().collection("users_metadata").doc(uid).get();
  const { webAuthnChallenge } = userDoc.data();

  let verification;
  try {
    verification = await verifyRegistrationResponse({
      response: registrationResponse,
      expectedChallenge: webAuthnChallenge,
      expectedOrigin: origin,
      expectedRPID: rpID,
      requireUserVerification: true,
    });
  } catch (error) {
    console.error("Error en verifyRegistrationResponse:", error);
    throw new functions.https.HttpsError("internal", error.message);
  }
  
  if (!verification.verified) {
    throw new functions.https.HttpsError("invalid-argument", "No se pudo verificar el registro.");
  }

  const { registrationInfo } = verification;
  const newAuthenticator = {
    ...registrationInfo,
    credentialID: Buffer.from(registrationInfo.credentialID).toString('base64url'),
    credentialPublicKey: Buffer.from(registrationInfo.credentialPublicKey).toString('base64url'),
  };

  await admin.firestore().collection("users_metadata").doc(uid).collection("authenticators").add(newAuthenticator);
  
  await admin.firestore().collection("users_metadata").doc(uid).update({ webAuthnChallenge: admin.firestore.FieldValue.delete() });

  return { verified: true };
});


// Funci√≥n 3: Genera las opciones (el desaf√≠o) para iniciar sesi√≥n
exports.generateAuthenticationOptions = functions.https.onCall(async (data, context) => {
  const { email } = data;
  if (!email) {
    throw new functions.https.HttpsError("invalid-argument", "Se debe proporcionar un correo.");
  }

  let userRecord;
  try {
    userRecord = await admin.auth().getUserByEmail(email);
  } catch (error) {
     throw new functions.https.HttpsError("not-found", "Usuario no encontrado.");
  }
  
  const { uid } = userRecord;
  const authenticatorsRef = admin.firestore().collection("users_metadata").doc(uid).collection("authenticators");
  const snapshot = await authenticatorsRef.get();

  if (snapshot.empty) {
      throw new functions.https.HttpsError("not-found", "No hay huellas registradas para este usuario.");
  }

  const userAuthenticators = [];
  snapshot.forEach(doc => {
      const data = doc.data();
      userAuthenticators.push({
          ...data,
          id: Buffer.from(data.credentialID, 'base64url'),
      });
  });

  const options = await generateAuthenticationOptions({
    rpID,
    allowCredentials: userAuthenticators.map(auth => ({
      id: auth.id,
      type: "public-key",
      transports: auth.transports,
    })),
    userVerification: "preferred",
  });

  await admin.firestore().collection("users_metadata").doc(uid).set({ webAuthnChallenge: options.challenge }, { merge: true });

  return options;
});

// Funci√≥n 4: Verifica la respuesta de inicio de sesi√≥n y crea un token personalizado
exports.verifyAuthentication = functions.https.onCall(async (data, context) => {
  const { email, authenticationResponse } = data;
  
  const userRecord = await admin.auth().getUserByEmail(email);
  const { uid } = userRecord;

  const userDoc = await admin.firestore().collection("users_metadata").doc(uid).get();
  const { webAuthnChallenge } = userDoc.data();

  const authenticatorsRef = admin.firestore().collection("users_metadata").doc(uid).collection("authenticators");
  const snapshot = await authenticatorsRef.get();
  
  let authenticator;
  // Buscamos el autenticador correcto que coincida con el ID de la credencial que nos env√≠a el cliente
  for (const doc of snapshot.docs) {
      const authData = doc.data();
      if (authData.credentialID === authenticationResponse.id) {
          authenticator = authData;
          break;
      }
  }

  if (!authenticator) {
    throw new functions.https.HttpsError("not-found", "El autenticador correspondiente no fue encontrado.");
  }

  let verification;
  try {
    verification = await verifyAuthenticationResponse({
      response: authenticationResponse,
      expectedChallenge: webAuthnChallenge,
      expectedOrigin: origin,
      expectedRPID: rpID,
      authenticator: {
          ...authenticator,
          credentialID: Buffer.from(authenticator.credentialID, 'base64url'),
          credentialPublicKey: Buffer.from(authenticator.credentialPublicKey, 'base64url'),
      },
      requireUserVerification: true,
    });
  } catch (error) {
     console.error("Error en verifyAuthenticationResponse:", error);
     throw new functions.https.HttpsError("internal", error.message);
  }

  if (!verification.verified) {
    throw new functions.https.HttpsError("unauthenticated", "Fall√≥ la verificaci√≥n de la huella.");
  }

  await admin.firestore().collection("users_metadata").doc(uid).update({ webAuthnChallenge: admin.firestore.FieldValue.delete() });
  
  const customToken = await admin.auth().createCustomToken(uid);
  return { verified: true, customToken };
});